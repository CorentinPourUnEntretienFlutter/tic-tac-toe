# Flutter/Dart Project - Tic Tac Toe

## Project Overview
This is a Flutter application for a Tic Tac Toe game. The project follows Flutter best practices and modern Dart conventions.

## Technology Stack
- **Framework**: Flutter 3.38.3
- **Language**: Dart 3.x
- **State Management**: Riverpod v2 with code generation (riverpod_generator)
- **Routing**: go_router for declarative navigation
- **Backend**: Firebase Realtime Database for real-time data synchronization
- **Platform**: Cross-platform (iOS, Android, Web, Desktop)

## Code Style & Conventions

### Dart Conventions
- Follow official Dart style guide: https://dart.dev/guides/language/effective-dart
- Use `lowerCamelCase` for variables, functions, and parameters
- Use `UpperCamelCase` for classes, enums, typedefs, and type parameters
- Use `lowercase_with_underscores` for library and file names
- Prefer `const` constructors when possible for performance
- Use trailing commas for better formatting
- Maximum line length: 80 characters (configurable in analysis_options.yaml)
- format on save

### Flutter Best Practices
- **Widgets**: Break down complex widgets into smaller, reusable components
- **State Management**: Keep business logic separate from UI code
- **Immutability**: Prefer immutable data structures and final fields
- **Keys**: Use keys when necessary for widget identity (especially in lists)
- **BuildContext**: Be careful with BuildContext usage in async operations
- **Performance**: Use `const` constructors
- **Responsiveness**: Design for multiple screen sizes

### File Organization
```
lib/
├── main.dart                 # App entry point
├── router.dart               # go_router configuration
├── models/                   # Data models
├── screens/                  # Full-page screens/views
├── widgets/                  # Reusable UI components
├── services/                 # Business logic, APIs, data services
│   └── firebase_service.dart # Firebase database interactions
├── utils/                    # Helper functions, constants
├── theme/                    # App theming and styling
└── providers/                # Riverpod providers
```

### Naming Conventions
- **Files**: `snake_case.dart` (e.g., `game_board.dart`)
- **Widgets**: `UpperCamelCase` (e.g., `GameBoard`, `PlayerTile`)
- **Private members**: Prefix with underscore (e.g., `_privateMethod`)
- **Constants**: `lowerCamelCase` for local, `kUpperCamelCase` for global constants

### Widget Structure
```dart
class MyWidget extends StatelessWidget {
  const MyWidget({
    super.key,
    required this.param1,
    this.param2,
  });

  final String param1;
  final int? param2;

  @override
  Widget build(BuildContext context) {
    return Container(
      // Widget implementation
    );
  }
}
```

### Routing with go_router
- **Declarative Routes**: Define all routes in a central `router.dart` file
- **Type-safe Navigation**: Use named routes with path parameters
- **Navigation Guards**: Implement redirects for authentication/authorization
- **Nested Navigation**: Support for nested routes and shell routes
- **Route Parameters**: Use path parameters (`/game/:id`) and query parameters

```

### Firebase Realtime Database
- **Service Layer**: Encapsulate all Firebase operations in service classes
- **Type Safety**: Create models to represent Firebase data structures
- **Streams**: Use Firebase streams with Riverpod StreamProviders for real-time updates
- **Error Handling**: Always handle Firebase exceptions (network errors, permission denied, etc.)
- **Offline Support**: Firebase Realtime Database supports offline persistence by default
- **Security**: Never commit `google-services.json` (Android) or `GoogleService-Info.plist` (iOS) to public repos

#### Data Structure Best Practices
```dart
// Flat structure is better for scalability
// Good:
games/
  game123/
    player1: "user_abc"
    player2: "user_xyz"
    board: [0,1,0,2,1,0,0,0,2]
    status: "in_progress"

// Avoid deeply nested structures
```

#### Firebase Service Pattern
```dart
class FirebaseService {
  final DatabaseReference _db = FirebaseDatabase.instance.ref();

  // Listen to real-time updates
  Stream<Game?> watchGame(String gameId) {
    return _db.child('games/$gameId').onValue.map((event) {
      if (event.snapshot.value == null) return null;
      return Game.fromJson(event.snapshot.value as Map);
    });
  }

  // Write data
  Future<void> updateGame(String gameId, Game game) async {
    await _db.child('games/$gameId').set(game.toJson());
  }

  // Delete data
  Future<void> deleteGame(String gameId) async {
    await _db.child('games/$gameId').remove();
  }
}
```

#### Integration with Riverpod
```dart
// Provider for Firebase service
final firebaseServiceProvider = Provider((ref) => FirebaseService());

// StreamProvider for real-time data
final gameStreamProvider = StreamProvider.family<Game?, String>((ref, gameId) {
  final service = ref.watch(firebaseServiceProvider);
  return service.watchGame(gameId);
});
```

#### Firebase Security Rules
- Configure security rules in Firebase Console
- Example rules for tic-tac-toe:
```json
{
  "rules": {
    "games": {
      "$gameId": {
        ".read": true,
        ".write": true
      }
    }
  }
}
```

#### Firebase Initialization
```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());
}
```

## Testing
- Write widget tests for UI components
- Write unit tests for business logic and models
- Use `test/` directory for test files
- Name test files as `*_test.dart`
- Aim for meaningful test coverage

## Documentation
- Add doc comments (`///`) for public APIs
- Include examples in documentation when helpful
- Document complex business logic
- Keep comments concise and meaningful

## Error Handling
- Use try-catch blocks for operations that may fail
- Provide user-friendly error messages
- Log errors appropriately for debugging
- Handle null safety properly (Dart 3.x sound null safety)

## Performance Considerations
- Use `const` constructors wherever possible
- Avoid expensive operations in `build()` methods
- Use `ListView.builder` for long lists
- Implement pagination for large datasets
- Profile the app regularly using Flutter DevTools

## Accessibility
- Add semantic labels for screen readers
- Ensure sufficient color contrast
- Support larger text sizes
- Test with TalkBack/VoiceOver

## Code Review Checklist
- [ ] Code follows Dart style guide
- [ ] No linter warnings or errors
- [ ] Widgets are appropriately sized and reusable
- [ ] State is managed efficiently
- [ ] Null safety is handled correctly
- [ ] Code is well-documented
- [ ] Tests are included for new features

## AI Assistant Guidelines
When helping with this project:
1. **Always** follow Flutter and Dart best practices
2. **Prioritize** code readability and maintainability
3. **Use** const constructors by default
4. **Suggest** breaking down large widgets into smaller components
5. **Consider** performance implications of widget rebuilds
6. **Implement** proper null safety
7. **Write** clean, self-documenting code
8. **Add** helpful comments for complex logic
9. **Follow** the established project structure
10. **Run** `flutter analyze` to check for issues

## Useful Commands
- `flutter run` - Run the app
- `flutter test` - Run tests
- `flutter analyze` - Static analysis
- `flutter format .` - Format code
- `flutter clean` - Clean build artifacts
- `flutter pub get` - Install dependencies
- `flutter doctor` - Check Flutter installation

## Dependencies Management
- Keep `pubspec.yaml` organized with clear sections
- Add comments for why specific packages are used
- Prefer well-maintained, popular packages
- Check package compatibility with null safety

### Required Firebase Packages
```yaml
dependencies:
  firebase_core: ^latest          # Core Firebase SDK
  firebase_database: ^latest      # Realtime Database
  
dev_dependencies:
  flutterfire_cli: ^latest       # Firebase configuration tool
```

### Firebase Configuration Steps
1. Install Firebase CLI: `npm install -g firebase-tools`
2. Install FlutterFire CLI: `dart pub global activate flutterfire_cli`
3. Configure Firebase: `flutterfire configure`
4. This generates `firebase_options.dart` with platform-specific configs
5. Add Firebase initialization in `main.dart`

